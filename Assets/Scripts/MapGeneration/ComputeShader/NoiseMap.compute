// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel NoiseMap
#include "Noise.compute"

static const float pi = 3.14159265;

RWStructuredBuffer<float> noiseMap;
int mapWidth;
int mapHeight;
float hexagonSize;

// Noise settings
StructuredBuffer<float3> octaveOffsets;
float3 offset;
int octaves;
float lacunarity;
float persistance;
float scale;
float strength;
float weightMultiplier;

int XYToIndex(uint x, uint y)
{
    return x + y * mapWidth;
}

float3 HexagonPosToWorldPos(int hexagonX, int hexagonY, float worldZ)
{
    float worldX = (hexagonY & 1) == 0
        ? hexagonX * hexagonSize
        : (hexagonX * hexagonSize) + (hexagonSize / 2);
    float worldY = hexagonY * hexagonSize * sin(pi / 3);
    return float3(worldX, worldY, worldZ);
}

[numthreads(16, 16, 1)]
void NoiseMap(int3 id : SV_DispatchThreadID)
{
    if (id.x >= mapWidth || id.y >= mapHeight)
    {
        return;
    }

    float3 pos = HexagonPosToWorldPos(id.x, id.y, 0);
    float finalValue = 0;
    float frequency = scale / 100;
    float amplitude = 1;
    float weight = 1;
    for (int i = 0; i < octaves; i++)
    {
        float noise = snoise(pos * frequency + octaveOffsets[i] + offset);
        float value = 1 - abs(noise);
        //value = noise;
        value = value * value;
        value *= weight;
        weight = max(min(value * weightMultiplier, 1), 0);

        finalValue += value * amplitude;
        amplitude *= persistance;
        frequency *= lacunarity;
    }

    finalValue *= strength;

    int index = XYToIndex(id.x, id.y);
    noiseMap[index] = finalValue;
}
